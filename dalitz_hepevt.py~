# (/usr/bin/python)
# Tested with Python 2.4.3 and ROOT 5.34/03 on SL5.3
###################################################################################################################
#                                                                                                                 #
# Python script to create hepevt files with di-muons from J/psi decay                                             #
#                                                                                                                 #
# Use PyROOT - so have access to ROOT facilities for random numbers, 4-vector manipulation, histograms.           #
#                                                                                                                 #     
#                                          Graham W. Wilson     March 10th 2014                                   #
# May need to check number of sig figs in print statement ...                     
#Notations:  4Vectors - v0 sum of all particles LAB frame       in notations generally referring to angles or dielectric system
#                       v1 gamma star                           (1) electron
#                       v2 photon                               (2) postitron
#                       v3 electron                             (3) photon
#                       v4 positron
#                       v5 sum of all particles CM frame
#                                #
################################################################################################################### 
# Try to consistently use " " only for file names ..
import sys
import ROOT
import math
import random
from dalitz_distribution import Dalitz
from dalitz_resolution import DalitzResolutionSmear
import argparse # argparse-1.2.1 argparse.py file installed by hand in my path (under root/lib actually)

#Check arguments from command-line
print 'This program is named: ', sys.argv[0]
print 'Number of arguments  : ', len(sys.argv)
print 'The arguments are    : ', str(sys.argv)
print ' '

parser = argparse.ArgumentParser(description='Generate displaced vertex di-muon hepevt files')
parser.add_argument('-s','--seed', type=int, default=4360, help='the random number seed')
parser.add_argument('-n','--nevs', type=int, default=2, help='number of events to generate')
parser.add_argument('-p','--momentum', type=float, default=10.0, help='parent particle momentum in the lab frame (GeV/c)')
parser.add_argument('-d','--vdisp', type=int, default=0, help='vertex displacement (mm)')
parser.add_argument('-v','--verbosity',help='increase output verbosity',action='store_true')
args = parser.parse_args()

print ' '
print ' seed       : ',args.seed
print ' nevs       : ',args.nevs
print ' momentum   : ',args.momentum
print ' vdisp (mm) : ',args.vdisp
print ' verbosity  : ',args.verbosity

verbose = args.verbosity            # Turn on or off debug printing

longformat = True                   # Use hepevt or HEPEvt format (in practice only the former is really wanted for now)
if longformat:
   outfile = "dalitz"+str(args.vdisp)+"mm.hepevt"
else:
   outfile = "Dalitz.HEPEvt"

print 'Using outfile : ',outfile

ofile = open( outfile , 'w' )
ofile2 = open( "dalitz_0mm_unsmeared.hepevt", 'w')

# Initialize histo file
f = ROOT.TFile("histos_dalitz.root", "update")

pi = math.pi 
##### histograms
##CM frame
hEepCM = ROOT.TH1D("hEepCM", "Energy of Positron CMpi0;Energy;Frequency of Energy",100,0,0.07)
hEemCM = ROOT.TH1D("hEemCM", "Energy of electron CMpi0;Energy;Frequency of Energy",100,0,0.07)
hEgmCM = ROOT.TH1D("hEgmCM", "Energy of photon CMpi0;Energy; Frequency of Energy",100,0,0.07)
hPepCM = ROOT.TH1D("hPepCM", "scalar magnitude of positron momentum CMpi0;momentum;Frequency of momentum",100,0,0.07)
hPemCM = ROOT.TH1D("hPemCM", "scalar magnitude of electron momentum CMpi0;momentum;Frequency of momentum",100,0,0.07)
hPgmCM = ROOT.TH1D("hPgmCM", "scalar magnitude of photon momentum CMpi0;momentum;Frequency of momentum",100,0,0.07)
hMpiECM = ROOT.TH2D("hMpiECM","Sum of Three particles energy vs Mpi invariant mass CMpi0;Energy;Mass",100,0.13,0.14,100,0.13,0.14)
hcos12CM = ROOT.TH1D("hcos12CM","opening angle between the electron postitron CMpi0;cos;frequency",100,-1.0,1.0)
hcos13CM = ROOT.TH1D("hcos13CM","opening angle between the electron and photon CMpi0;cos;frequency",100,-1.0,1.0)
hcos23CM = ROOT.TH1D("hcos23CM","opening angle between the positron and photon CMpi0;cos;frequency",100,-1.0,1.0)
hPhiepCM = ROOT.TH1D("hPhiepCM","Phi of positron CMpi0;phi;frequency of angle",100,-pi,pi)
hPhiemCM = ROOT.TH1D("hPhiemCM","Phi of electron CMpi0;phi;frequency of angle",100,-pi,pi)
hPhigmCM = ROOT.TH1D("hPhigmCM","Phi of photon CMpi0;phi;frequency of angle",100,0,2*pi)
hCosepCM = ROOT.TH1D("hCosepCM","cos theta of positron CMpi0;cos;frequency of cos",100,-1.0,1.0)
hCosemCM = ROOT.TH1D("hCosemCM","cos theta of electron CMpi0;cos;frequency of cos",100,-1.0,1.0)
hCosgmCM = ROOT.TH1D("hcosgmCM","cos theta of photon CMpi0;cos;frequency of cos",100,-1.0,1.0)
hPhiCos12CM = ROOT.TH2D("hPhiCos12CM","phi vs cos electron+postrion 4vector CMpi0;cos;phi",100,-1.0,1.0,100, -pi,pi)
hPhiCos13CM = ROOT.TH2D("hPhiCos13CM","phi vs cos electron+photon 4vector CMpi0;cos;phi",100,-1.0,1.0,100,-pi,pi)
hPhiCos23CM = ROOT.TH2D("hPhiCos23CM","phi vs cos positron+photon 4vector CMpi0;cos;phi",100,-1.0,1.0,100, -pi,pi)
hPhiCos123CM = ROOT.TH2D("hPhiCos123CM","phi vs cos all 3 particles 3vector CMpi0;cos;phi",100,-1.0,1.0,100,-pi,pi)

##Lab frame
hEepLAB = ROOT.TH1D("hEepLAB", "Energy of Positron LAB frame;Energy;Frequency of Energy",100,0,10.0)
hEemLAB = ROOT.TH1D("hEemLAB", "Energy of electron LAB frame;Energy;Frequency of Energy",100,0,10.0)
hEgmLAB = ROOT.TH1D("hEgmLAB", "Energy of photon LAB frame; Energy;Frequency of Energy",100,0,10.0)
hPepLAB = ROOT.TH1D("hPepLAB", "scalar magnitude of positron momentum LAB frame;momentum;Frequency of momentum",100,0,10.0)
hPemLAB = ROOT.TH1D("hPemLAB", "scalar magnitude of electron momentum LAB frame;momentum;Frequency of momentum",100,0,10.0)
hPgmLAB = ROOT.TH1D("hPgmLAB", "scalar magnitude of photon momentum LAB frame;momentum;Frequency of momentum",100,0,10.0)
hEconsLAB = ROOT.TH1D("hEconsLAB", "Sum of LAB frame energies;energy;frequency of Energy",100,9.0,11.0)
hPconsLAB = ROOT.TH1D("hPconsLAB", "Sum of LAB frame scalar magnitude of momentum;momentum;frequency of momentum",100,9.0,11.0)
hMconsLAB = ROOT.TH1D("hMconsLAB", "Reconstructed Mass (GeV); Mass (GeV); Events per 0.001 GeV",70,0.100,0.170)
hEConstrained = ROOT.TH1D("hEConstrained", "Constrained Energy (GeV); Energy (GeV); Events per 0.1 GeV",50,7.5,12.5)
hEConstrained2 = ROOT.TH1D("hEConstrained2", "Constrained Energy (GeV); Energy (GeV); Events per 0.01 GeV",100,9.5,10.5)
hEConstrained3 = ROOT.TH1D("hEConstrained3", "Constrained Energy (GeV); Energy (GeV); Events per 0.002 GeV",1000,9.5,10.5)
hcos12LAB = ROOT.TH1D("hcos12LAB","opening angle between the electron postitron LAB;cos;frequency",100,-1.0,1.0)
hcos13LAB = ROOT.TH1D("hcos13LAB","opening angle between the electron and photon LAB;cos;frequency",100,-1.0,1.0)
hcos23LAB = ROOT.TH1D("hcos23LAB","opening angle between the positron and photon LAB;cos;frequency",100,-1.0,1.0)
hPhiepLAB = ROOT.TH1D("hPhiepLAB","Phi of positron LAB;phi;frequency of angle",100,-pi,pi)
hPhiemLAB = ROOT.TH1D("hPhiemLAB","Phi of electron LAB;phi;frequency of angle",100,-pi,pi)
hPhigmLAB = ROOT.TH1D("hPhigmLAB","Phi of photon LAB;phi;frequency of angle",100,-pi,pi)
hCosepLAB = ROOT.TH1D("hCosepLAB","cos theta of positron LAB;cos;frequency of cos",100,-1.0,1.0)
hCosemLAB = ROOT.TH1D("hCosemLAB","cos theta of electron LAB;cos;frequency of cos",100,-1.0,1.0)
hCosgmLAB = ROOT.TH1D("hCosgmLAB","cos theta of photon LAB;cos;frequency of cos",100,-1.0,1.0)
hPhiCos12LAB = ROOT.TH2D("hPhiCos12LAB","phi vs cos electron+postrion 4vector LAB;cos;phi",100,-1.0,1.0,100, -pi,pi)
hPhiCos13LAB = ROOT.TH2D("hPhiCos13LAB","phi vs cos electron+photon 4vector LAB;cos;phi",100,-1.0,1.0,100, -pi,pi)
hPhiCos23LAB = ROOT.TH2D("hPhiCos23LAB","phi vs cos positron+photon 4vector LAB;cos;phi",100,-1.0,1.0,100, -pi,pi)
hPhiCos123LAB = ROOT.TH2D("hPhiCos123LAB","phi vs cos all 3 particles 3vector LAB;cos;phi",100,-1.0,1.0,100,-pi,pi)
hChisq = ROOT.TH1D("hChisq","Short-cut Fit; Chi-squared; Events per bin",100,0.0,10.0)
hMconstrained = ROOT.TH1D("hMconstrained","pion mass using adjusted photon energy;GEV;frequency of GEV",100,0.13,0.14)


######
hGausep = ROOT.TH1D("hGausep","distribution of positron pt;momentum;frequency of momentum",100,0,10)
hGausem = ROOT.TH1D("hGausem","distribution of electron pt;momentum;frequency of momentum",100,0,10)
hGausgm = ROOT.TH1D("hGausgm","distribution of photon energy;energy;frequency of energy",1000,0,10)
hkapem = ROOT.TH1D("hkapem","curvature electron;k;frequency of k",100,0,10)
hkapep = ROOT.TH1D("hkapep","curvature positron;k;frequency of k",100,0,10)
hE3calc = ROOT.TH1D("hE3calc","photon energy in terms of p1&p2;E;frequency of E",100,0,10)
#####


# Initialize RANLUX random number generator with luxury = 3
random = ROOT.TRandom1(args.seed,3)

p = args.momentum                          # in GeV/c
vertex_displacement = float(args.vdisp)    # in mm

#PDG
#m_pion = 3.096916
#m_gamma = 0.1056583715

#PYTHIA

# Decay = parent particle -> daughter particle_1 + daughter particle_2  (both daughters same mass)

m_pion = 0.13497          # the parent particle (here pi0 value)
m_gamma = 0.0              # the daughter particle (here photon) 

m_e = 0.000511	# mass of electron on GEV


# get x and y's from dalitz class for gammastar mass
xygen = Dalitz()
v = (2*m_e)/m_pion
xygen.setV(v)
xygen.setWmax(9000)

sm = DalitzResolutionSmear()
sm2 = DalitzResolutionSmear()
sm3 = DalitzResolutionSmear()

for j in range( 0, args.nevs ):
    x,y = xygen.generatePair()

    while xygen.testProbabilities(xygen.calculateProbability(x,y),x,y) == False:
	x,y = xygen.generatePair()
		
	
    # generate a new gamma star mass for each event
    m_gamma_star = math.sqrt(x * m_pion*m_pion)
    pcm = (m_pion*m_pion - m_gamma_star*m_gamma_star) / (2*m_pion)

# Generate random directions in CM frame of the gamma-gamma* 
    phicm = 2.0 * math.pi * random.Uniform( 0.0, 1.0 )
    costhcm = random.Uniform( -1.0, 1.0 )
    thetacm = math.acos( costhcm )

# Set up the 4-vectors of the two gamma in the CM system
    v1 = ROOT.TLorentzVector()
    v2 = ROOT.TLorentzVector()

    #fixing gammas along the x axis
    v1.SetXYZM( pcm, 0, 0, m_gamma_star)
    v2.SetXYZM(-pcm, 0, 0, m_gamma)


#############################################electrons second method
##here all parameters for dielectric system are dictated from Pi0 CM (1) represents electron (2) positron (3) photon in the variable notation

    #finding momentums of dielectric system
    #computing the lateral momentum of e1 and e2 in terms of x and y
    Pl1 = (m_pion/4) * ( (1-x) + y*(1+x) )
    Pl2 = (m_pion/4) * ( (1-x) - y*(1+x) )

    #computing the transverse momentum of e1 and e2 in terms of x and y
    Pt1 = math.sqrt( ((x*m_pion*m_pion/4) * (1-y*y)) - m_e*m_e )
    Pt2 = -Pt1


    #finding the Energies of the 3 particles in the system
    E1 = (m_pion/4) * ( (1+x) + y*(1-x) )
    E2 = (m_pion/4) * ( (1+x) - y*(1-x) )

    E3 = (m_pion/2) * (1-x)
    #E3 = 5

    P1 = math.sqrt( E1*E1 - m_e*m_e )
    P2 = math.sqrt( E2*E2 - m_e*m_e )

    phi2 = math.acos((E3*E3 + E2*E2 - E1*E1)/(2*P2*E3))
    phi1 = math.acos((E3*E3 + E1*E1 - E2*E2)/(2*P1*E3))

    #setup 4-vectors (random phi directin in spherical for the electrons)    
    v3 = ROOT.TLorentzVector()
    v4 = ROOT.TLorentzVector()

    #this will use polar coordinates, setting azimuthal axis to 0 since gamma is fixed along x
    e1dx , e2dx = Pl1, Pl2
    e1dy, e2dy = Pt1, Pt2
    v3.SetXYZM(e1dx,e1dy,0,m_e)
    v4.SetXYZM(e2dx,e2dy,0,m_e)

    #rotate the electron pair randomly about the x-axis
    Rotation = 2.0 * math.pi * random.Uniform( 0.0, 1.0 )
    v3.RotateX(Rotation)
    v4.RotateX(Rotation)
    
    #rotate the three particle system about all 3 axes, x is not first because gamma is fixed on the xaxis
    Rotation = 2.0 * math.pi * random.Uniform( 0.0, 1.0 )
    v2.RotateY(Rotation)
    v3.RotateY(Rotation)
    v4.RotateY(Rotation)

    Rotation = 2.0 * math.pi * random.Uniform(0.0,1.0)
    v2.RotateZ(Rotation)
    v3.RotateZ(Rotation)
    v4.RotateZ(Rotation)

    Rotation = 2.0 * math.pi * random.Uniform(0.0,1.0)
    v2.RotateX(Rotation)
    v3.RotateX(Rotation)
    v4.RotateX(Rotation)  
  

   #calculate opening angle
    #em & ep
    cos12 = (v3.Px()*v4.Px() + v3.Py()*v4.Py() + v3.Pz()*v4.Pz())/(v3.P()*v4.P())
    hcos12CM.Fill(cos12)
    hPhiCos12CM.Fill( (v3+v4).CosTheta(), (v3+v4).Phi() )
    #em & gm
    cos13 = (v2.Px()*v3.Px() + v2.Py()*v3.Py() + v2.Pz()*v3.Pz())/(v3.P()*v2.P())
    hcos13CM.Fill(cos13)
    hPhiCos13CM.Fill( (v3+v2).CosTheta(), (v3+v2).Phi() )
    #ep & gm
    cos23 = (v2.Px()*v4.Px() + v2.Py()*v4.Py() + v2.Pz()*v4.Pz())/(v4.P()*v2.P())
    hcos23CM.Fill(cos23)
    hPhiCos23CM.Fill( (v2+v4).CosTheta(), (v2+v4).Phi() )

    #plotting polar angles and angle combinations
    #positron 
    hPhiepCM.Fill(v4.Phi())
    hCosepCM.Fill(v4.CosTheta())

    #electron
    hPhiemCM.Fill(v3.Phi())
    hCosemCM.Fill(v3.CosTheta())
    
    #photon
    hPhigmCM.Fill(v2.Phi())
    hCosgmCM.Fill(v2.CosTheta())
   

    v5=v2+v3+v4

    hPhiCos123CM.Fill(v5.CosTheta(),v5.Phi())
    
    hEemCM.Fill(v3.E())
    hEepCM.Fill(v4.E())
    hEgmCM.Fill(v2.E())
    
    hPemCM.Fill(v3.P())
    hPepCM.Fill(v4.P())
    hPgmCM.Fill(v2.P())

    hMpiECM.Fill(v5.E(),v5.M())


#########################################################################
#starting to boost into lab
###############
    if verbose:    
       print ' '
       print 'Event',j
       print 'v1cm ',v1.P(),v1.Px(),v1.Py(),v1.Pz(),v1.E(),v1.M()
       print 'v2cm ',v2.P(),v2.Px(),v2.Py(),v2.Pz(),v2.E(),v2.M()
       print 'v3cm ',v3.P(),v3.Px(),v3.Py(),v3.Pz(),v3.E(),v3.M()
       print 'v4cm ',v4.P(),v4.Px(),v4.Py(),v4.Pz(),v4.E(),v4.M()
       print 'v5cm ',v5.P(),v5.Px(),v5.Py(),v5.Pz(),v5.E(),v5.M()
       print "phi1 phi2 ", phi1, phi2
    
# Generate random directions in lab frame
    phi = 2.0 * math.pi * random.Uniform( 0.0, 1.0 )
    costh = random.Uniform( -1.0, 1.0 )
    theta = math.acos( costh )
  

# Compute the corresponding boost vector (Note |beta| = p/E)
# So b must be directed along the photon momentum in the lab frame
    beta =p/math.sqrt(p*p+m_pion*m_pion)
#    print "beta ",beta
    bx = math.sin( theta ) * math.cos( phi )
    by = math.sin( theta ) * math.sin( phi )
    bz = math.cos( theta )
    b = ROOT.TVector3(bx,by,bz)
    b.SetMag(beta)

# Boost the gamma and 2 electrons  4-vectors from the CM frame to the lab
   # v1.Boost(b)
    v2.Boost(b)
    v3.Boost(b)
    v4.Boost(b)

#write untouched vectors to file for possible use
    print >>ofile2, 3
    print >>ofile2, 1, 22, 0, 0, 0, 0, v2.Px(), v2.Py(), v2.Pz(), v2.E(), v2.M()
    print >>ofile2, 1, 11, 0, 0, 0, 0, v3.Px(), v3.Py(), v3.Pz(), v3.E(), v3.M()
    print >>ofile2, 1, -11,0, 0, 0, 0, v4.Px(), v4.Py(), v4.Pz(), v4.E(), v4.M()

    #v2.SetXYZM(1.0,0.0,0.0,0.0)
# After boosting the system we can smear the 4 vectors
   # sm = DalitzResolutionSmear()
   # sm2 = DalitzResolutionSmear()
   # sm3 = DalitzResolutionSmear()
   
    sm.setParticleAttributes("photon",v2)
    sm.calculateAndSmear()
    v2 = sm.getVsmear()

    sm2.setParticleAttributes("electron",v3)
    sm2.calculateAndSmear()
    v3 = sm2.getVsmear()

    sm3.setParticleAttributes("positron",v4)
    sm3.calculateAndSmear()
    v4 = sm3.getVsmear()

    #get and plot kappas	
    k1 = 1/math.sqrt(v3.Px()*v3.Px() + v3.Py()*v3.Py())
    k2 = 1/math.sqrt(v4.Px()*v4.Px() + v4.Py()*v4.Py())
    hkapem.Fill(k1)
    hkapep.Fill(k2)


# The three particle system ..
    v0 = ROOT.TLorentzVector()
    v0 = v2 + v3 + v4

    hPhiCos123LAB.Fill(v0.CosTheta(),v0.Phi())

    hGausep.Fill(sm3.getGaus())
    hGausem.Fill(sm2.getGaus())
    hGausgm.Fill(sm.getGaus())

       #calculate opening angle
    #em & ep
    cos12 = (v3.Px()*v4.Px() + v3.Py()*v4.Py() + v3.Pz()*v4.Pz())/(v3.P()*v4.P())
    hcos12LAB.Fill(cos12)
    hPhiCos12LAB.Fill( (v3+v4).CosTheta(), (v3+v4).Phi() )
    #em & gm
    cos13 = (v2.Px()*v3.Px() + v2.Py()*v3.Py() + v2.Pz()*v3.Pz())/(v3.P()*v2.P())
    hcos13LAB.Fill(cos13)
    hPhiCos13LAB.Fill( (v3+v2).CosTheta(), (v3+v2).Phi() )
    #ep & gm
    cos23 = (v2.Px()*v4.Px() + v2.Py()*v4.Py() + v2.Pz()*v4.Pz())/(v4.P()*v2.P())
    hcos23LAB.Fill(cos23)
    hPhiCos23LAB.Fill( (v2+v4).CosTheta(), (v2+v4).Phi() )


    z12 = 2.0*(1.0-cos12)
    z13 = 2.0*(1.0-cos13)
    z23 = 2.0*(1.0-cos23)

    ecalc = ( (m_pion*m_pion) - (2.0*m_e*m_e) - (v3.P()*v4.P()*z12) ) / ( (v3.P() * z13 ) + (v4.P() * z23 ) )

    hEConstrained.Fill(ecalc + v3.E() + v4.E())
    hEConstrained2.Fill(ecalc + v3.E() + v4.E())
    hEConstrained3.Fill(ecalc + v3.E() + v4.E())

    hE3calc.Fill(ecalc)

    #plotting polar angles and angle combinations
    #positron 
    hPhiepLAB.Fill(v4.Phi())
    hCosepLAB.Fill(v4.CosTheta())

    #electron
    hPhiemLAB.Fill(v3.Phi())
    hCosemLAB.Fill(v3.CosTheta())
    
    #photon
    hPhigmLAB.Fill(v2.Phi())
    hCosgmLAB.Fill(v2.CosTheta())

    hEemLAB.Fill(v3.E())
    hEepLAB.Fill(v4.E())
    hEgmLAB.Fill(v2.E())
 
    hPemLAB.Fill(v3.P())
    hPepLAB.Fill(v4.P())
    hPgmLAB.Fill(v2.P())

    hEconsLAB.Fill(v0.E())
    hPconsLAB.Fill(v0.P())
    hMconsLAB.Fill(v0.M())

    

    chisq = math.pow(ecalc - v2.E(),2)/sm2.getVariance()
    hChisq.Fill(chisq)

    Mconstrained = math.sqrt(math.pow(2*m_e,2) + v3.P()*v4.P()*z12 + ecalc*v3.P()*z13 + ecalc*v4.P()*z23)

    hMconstrained.Fill(Mconstrained)


# Include the vertex - for now make this collinear with the di-muon momentum
    vtx = ROOT.TVector3(bx,by,bz)
    vtx.SetMag( vertex_displacement )

    if verbose:
#       print 'beta ',b.X(), b.Y(), b.Z(), b.Mag()
       print 'Smeared : '
       print 'photon ',v2.Px(),v2.Py(),v2.Pz(),v2.P(),v2.E(),v2.M()
       print 'e-     ',v3.Px(),v3.Py(),v3.Pz(),v3.P(),v3.E(),v3.M()
       print 'e+     ',v4.Px(),v4.Py(),v4.Pz(),v4.P(),v4.E(),v4.M() 
       print 'System ',v0.Px(),v0.Py(),v0.Pz(),v0.P(),v0.E(),v0.M()
       print 'Constrained Energy (adjusting Egamma) ',ecalc+v3.E()+v4.E()

    IDHEP1   =  22
    IDHEP2   =  22 
    JDAHEP1 = 0 
    JDAHEP2 = 0
    JMOHEP1 = 0
    JMOHEP2 = 0  #electron11 #positron-11


        
    print >>ofile, 3
# Note for now VHEP4 element is set assuming that the parent has beta=1

#NOTE: need to add functionality for outputing dalitz 4vectors to be read into resolution smearing
    if longformat:
       print >>ofile, 1, 22, 0, 0, 0, 0, v2.Px(), v2.Py(), v2.Pz(), v2.E(), v2.M() #, vtx.X(), vtx.Y(), vtx.Z(), vtx.Mag()
       print >>ofile, 1, 11, 0, 0, 0, 0, v3.Px(), v3.Py(), v3.Pz(), v3.E(), v3.M()#, vtx.X(), vtx.Y(), vtx.Z(), vtx.Mag()
       print >>ofile, 1, -11,0, 0, 0, 0, v4.Px(), v4.Py(), v4.Pz(), v4.E(), v4.M()#, vtx.X(), vtx.Y(), vtx.Z(), vtx.Mag()
    else:
       print >>ofile, 1, 22, 0, 0, v2.Px(), v2.Py(), v2.Pz(), v2.M()
       print >>ofile, 1, 11, 0, 0, v3.Px(), v3.Py(), v3.Pz(), v3.M()
       print >>ofile, 1, -11,0, 0, v4.Px(), v4.Py(), v4.Pz(), v4.M()


# Save the histograms to a file for potential later inspection directly in ROOT
f.Write()
