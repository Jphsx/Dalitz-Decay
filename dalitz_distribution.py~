 # (/usr/bin/python)
# Tested with Python 2.4.3 and ROOT 5.34/03 on SL5.3
###################################################################################################################
#                                                                                                                 #
# Python script to create random x and y values and test them in the dilatz distribution                          #
#                                                                                                                 #
# Use PyROOT - so have access to ROOT facilities for random numbers, 4-vector manipulation, histograms.           #
#                                                                                                                 #     
#                                          Justin Anguiano     June 19th 2015                                     #
#                                                     #
################################################################################################################### \

import sys
import ROOT
import math
import random
import argparse

class Dalitz:
	__v=0.007572053
	__Beta=0.0
	__Wmax=0.0
	__random = ROOT.TRandom1(1000,3)
	



	def __init__(self):
		pass
	
	def setV(self, V):
		# v = 2m/M where m is electron mass and M is pion mass
		self.__v=V
		return

	def setWmax(self, weight):
		self.__Wmax=weight
		return

	def generateRand(self, seed):
		self.__random = ROOT.TRandom1(seed,3)
		return


	def generateX(self):
		#create a random uniform number within the [v^2,1] domain
		lowerBound = self.__v * self.__v
		xVal = self.__random.Uniform(lowerBound, 1)
		#calculateBeta()
	
		return xVal
		
	def generatePair(self):
		#create x then create y based on their domain (then set Beta)
		xVal = self.generateX()
		self.calculateBeta(xVal)
		yVal = self.__random.Uniform(-(self.__Beta),self.__Beta )

		return xVal, yVal 

	def calculateBeta(self, x):
		# after x or x&y is generated determine the domain of y [-B,B]
		self.__Beta = math.sqrt( 1 - ( (self.__v * self.__v)/ x ) )
		return 

	def calculateProbability(self, x, y):
		# determine p(x,y)
		# the probability function is given by |1+ax|^2 (1-x)^3/4x [1+y^2 + v^2/x] where a=0.033
		a=0.033
		Pxy = (math.pow(math.fabs(1+a*x),2)) *((math.pow(1-x,3))/(4*x)) *(1+y*y + (self.__v*self.__v)/x )
		return Pxy

	def testProbabilities(self, p, x, y):
		# generate a random number between 0 and Wmax uniformly ( make sure p is never > Wmax)
		testValue = self.__random.Uniform( 0.0, self.__Wmax )
		#print testValue, p
		#testValue = 0.0
		if p>self.__Wmax :
			print "p exceeds Wmax ", p,testValue, "(x,y)", x, y
			sys.exit(0)
			return False
		if p > testValue :
			#print "point valid ",p,testValue, self.__Wmax, "(x,y)", x, y
			return True 
			
		else :
			#print "throwing out ",p,testValue, self.__Wmax, "(x,y)", x, y
			return False
			
	
#	def calculateWmax(self):
		#self.setWmax(0.0)
		#looks at the boundaries of x&y and tests all possible permutations of the domain bounds and midpoints and stores the largest P(x,y)
#		sampleX = [self.__v * self.__v, (1.0+math.pow(self.__v,2))/2 , 1.0 ]
#		sampleY = [-(self.__Beta), 0 , self.__Beta ]
		
#		maxValue = 0.0
#		Pxy = 0.0
#		a=0.033

#		for x in range(len(sampleX)):
#			for y in range(len(sampleY)):
#				Pxy = (math.pow(math.fabs(1+a*sampleX[x]),2))*((math.pow(1-sampleX[x],3))/(4*sampleX[x]))*(1+sampleY[y]*sampleY[y] + (self.__v*self.__v)/sampleX[x] )
#				
#				if Pxy > maxValue :
#					maxValue = Pxy
#
#		self.setWmax(maxValue*2)
#		return

	def calculateWmax(self):
		#iterate of x range and y range, determine y bounds at each x, then save the max value from the rn
		maxValue=0.0
		stepSize = 5e-4
		maxX=0
		maxY=0
		print "heres what we got before going in"
		print stepSize
		x = self.__v * self.__v
		print x
		while x < 1.0 :
			#determine Beta range
			beta = math.sqrt(1- (math.pow(self.__v,2))/x)
			y = -beta
			while y < beta :
				Pxy = (math.pow(math.fabs(1+0.033*x),2))*((math.pow(1-x,3))/(4*x))*(1+y*y + (self.__v*self.__v)/x )
				if Pxy > maxValue :
					maxValue=Pxy
					maxX=x
					maxY=y
					print "found a new max"
					print maxValue
				y=y+stepSize
			x=x+stepSize

		self.setWmax(maxValue*2)
		print maxValue
		print x,y
		return
				
		
		

	def test(self, q):
		print q
		return

def main():
	instance = Dalitz()
	# Initialize histo file
	f = ROOT.TFile("dalitz_dist.root", "update")
	# Book histograms
	hx = ROOT.TH1D("hx","XValues;X;Frequency of X",100,0.0,1.0)
	hy = ROOT.TH1D("hy","YValues;Y;Frequency of Y",100,-1.0,1.0)
	hp = ROOT.TH1D("hp","P(x,y);Probability;Frequency of Probability",100,0.0,14000)
	hpx = ROOT.TH2D("hpx","P(x,y) vs X;X value;Probability",100,0.0,1.0,100,0.0,14000)
	hpy = ROOT.TH2D("hpy","P(x,y) vs Y;Y value;Probability",100,0.0,1.0,100,0.0,14000)
	hxy = ROOT.TH2D("hxy","X vs Y;X value;Y value",100,0.0,1.0,100,0.0,1.0)
	heff = ROOT.TH1D("heff","heff",2,-0.5,1.5)
	
	#get number of points to generate and iterate through N (use arg parser)
	parser = argparse.ArgumentParser(description='Generate distribtion of dalitz differential decay rate')
	parser.add_argument('-n','--nevs', type=int, default=1, help='N sample size')
	parser.add_argument('-s','--seed', type=int, default=1, help='the random number seed')

	args = parser.parse_args()
	
	
	#set initial values (using electron and pion)
	m_pion = 0.13497 
	m_e = 0.000511
	v = (2*m_e)/m_pion
	instance.setV(v)
	#instance.calculateWmax()
	instance.setWmax( 9000)
	#f2 = ROOT.TF2("f2","((1.0+0.033*x)*(1.0+0.033*x))*(((1.0-x)*(1.0-x)*(1.0-x))/(4.0*x))*(1.0+y*y + ((2.0*0.000511/0.13497)*(2.0*0.000511/0.13497)/x))",5.73e-5,1.0,-0.9997,0.9997)
	
	if args.seed:
		instance.generateRand( args.seed)
		
	acceptedValues=0
	#for j in range( 0, args.nevs ):
	while acceptedValues < 100 :
	#generate pair
		x,y=instance.generatePair()
		
	#make sure beta is calculated 
	#calculate probability
		pxy = instance.calculateProbability(x,y)
	#test probability
		if instance.testProbabilities(pxy,x,y):
                        acceptedValues +=1		
			#collect points into data structure
			#populate histogram
			hx.Fill(x)
			hy.Fill(y)
			hp.Fill(pxy)
			hpx.Fill(x,pxy)
			hpy.Fill(y,pxy)
			hxy.Fill(x,y)
                        heff.Fill(1.0)
                else :
                        heff.Fill(0.0)
        
	#f2.Write()
	f.Write()

#if  __name__ =='__main__':
 #   main()
